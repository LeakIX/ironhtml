/**
 * Integration tests using parse5 to validate HTML output from ironhtml.
 *
 * These tests verify that the HTML generated by our Rust builder can be
 * correctly parsed by parse5, a spec-compliant HTML5 parser.
 */

import * as parse5 from "parse5";
import { execSync } from "child_process";
import { strict as assert } from "assert";

// Test utilities
let passed = 0;
let failed = 0;

function test(name, fn) {
  try {
    fn();
    console.log(`  âœ“ ${name}`);
    passed++;
  } catch (error) {
    console.log(`  âœ— ${name}`);
    console.log(`    ${error.message}`);
    failed++;
  }
}

function findElement(node, tagName) {
  if (node.tagName === tagName) return node;
  if (node.childNodes) {
    for (const child of node.childNodes) {
      const found = findElement(child, tagName);
      if (found) return found;
    }
  }
  return null;
}

function findAllElements(node, tagName, results = []) {
  if (node.tagName === tagName) results.push(node);
  if (node.childNodes) {
    for (const child of node.childNodes) {
      findAllElements(child, tagName, results);
    }
  }
  return results;
}

function getTextContent(node) {
  if (node.nodeName === "#text") return node.value;
  if (node.childNodes) {
    return node.childNodes.map(getTextContent).join("");
  }
  return "";
}

function getAttribute(node, name) {
  if (!node.attrs) return null;
  const attr = node.attrs.find((a) => a.name === name);
  return attr ? attr.value : null;
}

// Run Rust test binary to generate HTML samples
function generateHtml() {
  try {
    const output = execSync(
      "cargo run --manifest-path ../../Cargo.toml --example parse5_samples 2>/dev/null",
      {
        cwd: import.meta.dirname,
        encoding: "utf-8",
      }
    );
    return JSON.parse(output);
  } catch (error) {
    console.error("Failed to run Rust example. Creating example first...");
    throw error;
  }
}

// =============================================================================
// Test Suites
// =============================================================================

console.log("\nparse5 Integration Tests\n");
console.log("========================\n");

// -----------------------------------------------------------------------------
// Basic Structure Tests
// -----------------------------------------------------------------------------

console.log("Basic Structure:");

let samples;
try {
  samples = generateHtml();
} catch {
  console.log(
    "  âš  Skipping Rust integration tests (example not available yet)\n"
  );
  samples = null;
}

if (samples) {
  test("simple element parses correctly", () => {
    const doc = parse5.parseFragment(samples.simple_div);
    const div = findElement(doc, "div");
    assert.ok(div, "div element should exist");
    assert.equal(getTextContent(div).trim(), "Hello");
  });

  test("nested elements parse correctly", () => {
    const doc = parse5.parseFragment(samples.nested);
    const div = findElement(doc, "div");
    const span = findElement(div, "span");
    assert.ok(div, "div element should exist");
    assert.ok(span, "span element should exist");
    assert.equal(getTextContent(span).trim(), "Nested");
  });

  test("attributes are preserved", () => {
    const doc = parse5.parseFragment(samples.with_attrs);
    const div = findElement(doc, "div");
    assert.equal(getAttribute(div, "class"), "container");
    assert.equal(getAttribute(div, "id"), "main");
    assert.equal(getAttribute(div, "data-value"), "123");
  });

  test("void elements are self-closing", () => {
    const doc = parse5.parseFragment(samples.void_elements);
    const br = findElement(doc, "br");
    const img = findElement(doc, "img");
    const input = findElement(doc, "input");
    assert.ok(br, "br element should exist");
    assert.ok(img, "img element should exist");
    assert.ok(input, "input element should exist");
    assert.equal(getAttribute(img, "src"), "test.jpg");
    assert.equal(getAttribute(img, "alt"), "Test");
  });

  test("special characters are escaped in text", () => {
    const doc = parse5.parseFragment(samples.escaped_text);
    const text = getTextContent(doc);
    assert.ok(text.includes("<"), "< should be present as text");
    assert.ok(text.includes(">"), "> should be present as text");
    assert.ok(text.includes("&"), "& should be present as text");
  });

  test("special characters are escaped in attributes", () => {
    const doc = parse5.parseFragment(samples.escaped_attrs);
    const div = findElement(doc, "div");
    const value = getAttribute(div, "data-value");
    assert.ok(value.includes('"'), 'quote should be in attribute value');
    assert.ok(value.includes("&"), "& should be in attribute value");
  });

  test("complete document structure", () => {
    const doc = parse5.parse(samples.full_document);
    const html = findElement(doc, "html");
    const head = findElement(html, "head");
    const body = findElement(html, "body");
    const title = findElement(head, "title");

    assert.ok(html, "html element should exist");
    assert.ok(head, "head element should exist");
    assert.ok(body, "body element should exist");
    assert.ok(title, "title element should exist");
    assert.equal(getTextContent(title), "Test Page");
  });

  test("table structure", () => {
    const doc = parse5.parseFragment(samples.table);
    const table = findElement(doc, "table");
    const thead = findElement(table, "thead");
    const tbody = findElement(table, "tbody");
    const headerRows = findAllElements(thead, "tr");
    const bodyRows = findAllElements(tbody, "tr");

    assert.ok(table, "table element should exist");
    assert.ok(thead, "thead element should exist");
    assert.ok(tbody, "tbody element should exist");
    assert.equal(headerRows.length, 1, "should have 1 header row");
    assert.ok(bodyRows.length >= 1, "should have at least 1 body row");
  });

  test("list structure", () => {
    const doc = parse5.parseFragment(samples.list);
    const ul = findElement(doc, "ul");
    const items = findAllElements(ul, "li");

    assert.ok(ul, "ul element should exist");
    assert.equal(items.length, 3, "should have 3 list items");
  });

  test("form elements", () => {
    const doc = parse5.parseFragment(samples.form);
    const form = findElement(doc, "form");
    const inputs = findAllElements(form, "input");
    const button = findElement(form, "button");

    assert.ok(form, "form element should exist");
    assert.ok(inputs.length >= 1, "should have at least 1 input");
    assert.ok(button, "button element should exist");
    assert.equal(getAttribute(form, "method"), "post");
  });

  test("semantic elements", () => {
    const doc = parse5.parseFragment(samples.semantic);
    const header = findElement(doc, "header");
    const nav = findElement(doc, "nav");
    const main = findElement(doc, "main");
    const article = findElement(doc, "article");
    const footer = findElement(doc, "footer");

    assert.ok(header, "header element should exist");
    assert.ok(nav, "nav element should exist");
    assert.ok(main, "main element should exist");
    assert.ok(article, "article element should exist");
    assert.ok(footer, "footer element should exist");
  });

  test("boolean attributes", () => {
    const doc = parse5.parseFragment(samples.boolean_attrs);
    const input = findElement(doc, "input");
    const button = findElement(doc, "button");

    // parse5 includes boolean attributes with empty string value
    assert.ok(
      input.attrs.some((a) => a.name === "disabled"),
      "disabled attribute should exist"
    );
    assert.ok(
      input.attrs.some((a) => a.name === "required"),
      "required attribute should exist"
    );
  });

  test("deeply nested structure", () => {
    const doc = parse5.parseFragment(samples.deeply_nested);
    let node = doc;
    let depth = 0;

    // Count nesting depth
    while (node.childNodes && node.childNodes.length > 0) {
      const element = node.childNodes.find((n) => n.tagName);
      if (!element) break;
      node = element;
      depth++;
    }

    assert.ok(depth >= 5, `should be at least 5 levels deep, got ${depth}`);
  });
}

// -----------------------------------------------------------------------------
// Static HTML Tests (no Rust dependency)
// -----------------------------------------------------------------------------

console.log("\nStatic HTML Validation:");

test("parse5 handles HTML entities", () => {
  const html = "<p>&lt;script&gt;alert('xss')&lt;/script&gt;</p>";
  const doc = parse5.parseFragment(html);
  const p = findElement(doc, "p");
  const text = getTextContent(p);
  assert.ok(text.includes("<script>"), "entities should be decoded");
});

test("parse5 handles unicode", () => {
  const html = "<p>Hello ä¸–ç•Œ ğŸŒ</p>";
  const doc = parse5.parseFragment(html);
  const p = findElement(doc, "p");
  const text = getTextContent(p);
  assert.ok(text.includes("ä¸–ç•Œ"), "unicode should be preserved");
  assert.ok(text.includes("ğŸŒ"), "emoji should be preserved");
});

test("parse5 handles comments", () => {
  const html = "<div><!-- comment --><span>text</span></div>";
  const doc = parse5.parseFragment(html);
  const div = findElement(doc, "div");
  const comment = div.childNodes.find((n) => n.nodeName === "#comment");
  assert.ok(comment, "comment should be preserved");
  assert.equal(comment.data, " comment ");
});

test("parse5 handles doctype", () => {
  const html = "<!DOCTYPE html><html><head></head><body></body></html>";
  const doc = parse5.parse(html);
  assert.ok(doc.childNodes[0].nodeName === "#documentType");
});

test("parse5 handles multiple classes", () => {
  const html = '<div class="foo bar baz"></div>';
  const doc = parse5.parseFragment(html);
  const div = findElement(doc, "div");
  assert.equal(getAttribute(div, "class"), "foo bar baz");
});

test("parse5 handles empty attributes", () => {
  const html = "<input readonly>";
  const doc = parse5.parseFragment(html);
  const input = findElement(doc, "input");
  assert.ok(
    input.attrs.some((a) => a.name === "readonly"),
    "readonly should exist"
  );
});

// -----------------------------------------------------------------------------
// Summary
// -----------------------------------------------------------------------------

console.log("\n------------------------");
console.log(`Results: ${passed} passed, ${failed} failed`);
console.log("------------------------\n");

process.exit(failed > 0 ? 1 : 0);
